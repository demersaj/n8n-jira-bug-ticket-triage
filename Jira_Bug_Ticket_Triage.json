{
  "name": "Jira Bug Ticket Triage & Notification",
  "nodes": [
    {
      "parameters": {
        "events": [
          "jira:issue_created"
        ],
        "additionalFields": {}
      },
      "id": "e4c2f0e1-c4c4-481d-b630-7680a73e71e9",
      "name": "Jira Trigger - New Bug Created",
      "type": "n8n-nodes-base.jiraTrigger",
      "typeVersion": 1,
      "position": [
        85328,
        20400
      ],
      "webhookId": "jira-bug-webhook",
      "alwaysOutputData": false,
      "retryOnFail": true,
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "combineOperation": "all"
          },
          "conditions": [
            {
              "id": "is_bug",
              "leftValue": "={{ $json.issue?.fields?.issuetype?.name || $json.fields?.issuetype?.name || $json.issuetype?.name || $json.body?.issue?.fields?.issuetype?.name || $json.body?.fields?.issuetype?.name || $('Jira Trigger - New Bug Created').item.json.issue?.fields?.issuetype?.name || $('Jira Trigger - New Bug Created').item.json.fields?.issuetype?.name || '' }}",
              "rightValue": "Bug",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "not_it_project",
              "leftValue": "={{ $json.issue?.fields?.project?.key || $json.issue?.key || $json.fields?.project?.key || $json.project?.key || $json.body?.issue?.fields?.project?.key || $json.body?.issue?.key || $('Jira Trigger - New Bug Created').item.json.issue?.fields?.project?.key || $('Jira Trigger - New Bug Created').item.json.issue?.key || $('Jira Trigger - New Bug Created').item.json.fields?.project?.key || $('Jira Trigger - New Bug Created').item.json.key || '' }}",
              "rightValue": "IT",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "3336141a-20f9-472f-b40f-5c26502f3f8f",
      "name": "Check if Bug Ticket",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        85520,
        20576
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "combineOperation": "all"
          },
          "conditions": [
            {
              "id": "not_already_triaged",
              "leftValue": "={{ (() => { const labels = $json.issue?.fields?.labels || $json.fields?.labels || $json.body?.issue?.fields?.labels || $json.body?.fields?.labels || []; return Array.isArray(labels) ? labels.includes('auto-triaged') : (labels ? labels.split(', ').includes('auto-triaged') : false); })() }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "08889460-1ed1-4c7b-877b-9729c99a6303",
      "name": "Check if Already Triaged",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        85696,
        20576
      ]
    },
    {
      "parameters": {
        "operation": "update",
        "issueKey": "={{ $('Jira Trigger - New Bug Created').item.json.issue?.key || $('Jira Trigger - New Bug Created').item.json.key || $input.first().json.issue?.key || $input.first().json.key }}",
        "updateFields": {
          "labels": "={{ (() => { const labels = $input.first().json.issue?.fields?.labels || $input.first().json.fields?.labels || $input.first().json.body?.issue?.fields?.labels || $input.first().json.body?.fields?.labels || []; return Array.isArray(labels) ? [...labels.filter(l => l !== 'auto-triaged'), 'auto-triaged'] : (labels ? labels.split(', ').filter(l => l && l !== 'auto-triaged').concat(['auto-triaged']) : ['auto-triaged']); })() }}"
        }
      },
      "id": "94a99ccd-4cda-4b3b-8265-b34bdeff8036",
      "name": "Mark as Processing",
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        85888,
        20576
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": true,
        "options": {
          "fields": "summary,description,status,created,reporter,priority,components,labels,updated,attachment",
          "jql": "=project in (PRODBUGS, DEVBUGS, \"Andrew Bug Test\") AND issuetype = Bug AND status != Closed AND status != Resolved AND created >= -90d ORDER BY created DESC"
        }
      },
      "id": "afc41cd2-e22d-47e5-982a-8ada6ce8ca8a",
      "name": "Get Recent Bug Tickets",
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        85712,
        20400
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "new_ticket_key",
              "name": "newTicketKey",
              "value": "={{ $('Jira Trigger - New Bug Created').item.json.issue?.key || $('Jira Trigger - New Bug Created').item.json.key || $input.first().json.issue?.key || $input.first().json.key || 'TEST-000' }}",
              "type": "string"
            },
            {
              "id": "new_ticket_summary",
              "name": "newTicketSummary",
              "value": "={{ $('Jira Trigger - New Bug Created').item.json.issue?.fields?.summary || $('Jira Trigger - New Bug Created').item.json.fields?.summary || $input.first().json.issue?.fields?.summary || $input.first().json.fields?.summary || 'Test ticket summary' }}",
              "type": "string"
            },
            {
              "id": "new_ticket_description",
              "name": "newTicketDescription",
              "value": "={{ $('Jira Trigger - New Bug Created').item.json.issue?.renderedFields?.description || $('Jira Trigger - New Bug Created').item.json.issue?.fields?.description || $('Jira Trigger - New Bug Created').item.json.renderedFields?.description || $('Jira Trigger - New Bug Created').item.json.fields?.description || $input.first().json.issue?.renderedFields?.description || $input.first().json.issue?.fields?.description || $input.first().json.renderedFields?.description || $input.first().json.fields?.description || 'No description provided' }}",
              "type": "string"
            },
            {
              "id": "new_ticket_reporter",
              "name": "newTicketReporter",
              "value": "={{ $('Jira Trigger - New Bug Created').item.json.issue?.fields?.reporter?.displayName || $('Jira Trigger - New Bug Created').item.json.fields?.reporter?.displayName || $input.first().json.issue?.fields?.reporter?.displayName || $input.first().json.fields?.reporter?.displayName || 'Unknown' }}",
              "type": "string"
            },
            {
              "id": "new_ticket_priority",
              "name": "newTicketPriority",
              "value": "={{ $('Jira Trigger - New Bug Created').item.json.issue?.fields?.priority?.name || $('Jira Trigger - New Bug Created').item.json.fields?.priority?.name || $input.first().json.issue?.fields?.priority?.name || $input.first().json.fields?.priority?.name || 'None' }}",
              "type": "string"
            },
            {
              "id": "new_ticket_components",
              "name": "newTicketComponents",
              "value": "={{ (() => { const components = $('Jira Trigger - New Bug Created').item.json.issue?.fields?.components || $('Jira Trigger - New Bug Created').item.json.fields?.components || $input.first().json.issue?.fields?.components || $input.first().json.fields?.components || []; return components.map(c => c.name).join(', ') || 'None'; })() }}",
              "type": "string"
            },
            {
              "id": "new_ticket_labels",
              "name": "newTicketLabels",
              "value": "={{ (() => { const labels = $('Jira Trigger - New Bug Created').item.json.issue?.fields?.labels || $('Jira Trigger - New Bug Created').item.json.fields?.labels || $input.first().json.issue?.fields?.labels || $input.first().json.fields?.labels || []; return Array.isArray(labels) ? labels.join(', ') : (labels || 'None'); })() }}",
              "type": "string"
            },
            {
              "id": "existing_tickets_count",
              "name": "existingTicketsCount",
              "value": "={{ $input.all().length }}",
              "type": "number"
            },
            {
              "id": "jira_base_url",
              "name": "jiraBaseUrl",
              "value": "={{ (() => { const self = $('Jira Trigger - New Bug Created').item.json.issue?.self || $('Jira Trigger - New Bug Created').item.json.self || $input.first().json.issue?.self || $input.first().json.self || ''; const match = self.match(/https?:\\/\\/([^.]+)\\.atlassian\\.net/); return match ? match[1] + '.atlassian.net' : 'webai-dev.atlassian.net'; })() }}",
              "type": "string"
            },
            {
              "id": "new_ticket_attachments",
              "name": "newTicketAttachments",
              "value": "={{ JSON.stringify($('Jira Trigger - New Bug Created').item.json.issue?.fields?.attachment || $('Jira Trigger - New Bug Created').item.json.fields?.attachment || $input.first().json.issue?.fields?.attachment || $input.first().json.fields?.attachment || []) }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "08da659c-74e6-48dc-a8e0-c1703175eb59",
      "name": "Extract New Ticket Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [
        86048,
        20576
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get the new ticket data from Extract New Ticket Data node\nconst newTicket = $('Extract New Ticket Data').item.json;\nconst newTicketKey = newTicket.newTicketKey;\n\n// Debug: Log the extracted data to help troubleshoot\n// console.log('Extracted ticket data:', JSON.stringify(newTicket, null, 2));\n\n// Get all existing tickets from Get Recent Bug Tickets node, EXCLUDING the new ticket\nconst existingTickets = $input.all()\n  .filter(item => item.json.key !== newTicketKey) // Filter out the new ticket\n  .map(item => ({\n    key: item.json.key,\n    summary: item.json.fields.summary,\n    description: (item.json.fields.description || '').substring(0, 300),\n    status: item.json.fields.status.name,\n    components: item.json.fields.components?.map(c => c.name).join(', ') || 'None',\n    labels: item.json.fields.labels?.join(', ') || 'None',\n    created: item.json.fields.created\n  }));\n\n// Parse attachments and identify log files\nconst attachments = newTicket.newTicketAttachments ? (typeof newTicket.newTicketAttachments === 'string' ? JSON.parse(newTicket.newTicketAttachments) : newTicket.newTicketAttachments) : [];\nconst logFileExtensions = ['.log', '.txt', '.out', '.err', '.debug', '.trace'];\nconst logFiles = attachments.filter(att => {\n  const filename = (att.filename || att.name || '').toLowerCase();\n  return logFileExtensions.some(ext => filename.endsWith(ext)) || \n         filename.includes('log') || \n         filename.includes('error') || \n         filename.includes('debug');\n}).slice(0, 3); // Limit to first 3 log files\n\nreturn {\n  json: {\n    newTicketKey: newTicket.newTicketKey,\n    newTicketSummary: newTicket.newTicketSummary,\n    newTicketDescription: newTicket.newTicketDescription,\n    newTicketReporter: newTicket.newTicketReporter,\n    newTicketPriority: newTicket.newTicketPriority,\n    newTicketComponents: newTicket.newTicketComponents,\n    newTicketLabels: newTicket.newTicketLabels,\n    newTicketAttachments: attachments,\n    logFiles: logFiles,\n    hasLogFiles: logFiles.length > 0,\n    jiraBaseUrl: newTicket.jiraBaseUrl,\n    existingTickets: existingTickets,\n    existingTicketsCount: existingTickets.length\n  }\n};"
      },
      "id": "1cff3c91-1286-412a-b1d5-25fdf115e30b",
      "name": "Prepare Data for Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        85904,
        20416
      ]
    },
    {
      "parameters": {
        "jsCode": "// Pass through ticket data with log file information\nreturn $input.all().map(item => ({ json: item.json }));"
      },
      "id": "cdcb150c-d3a1-4fd2-8701-5ca0f32a8cc8",
      "name": "Fetch Log File Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        86064,
        20416
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.logFiles && $json.logFiles.length > 0 && $json.logFiles[0].content ? $json.logFiles[0].content : '' }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "jiraSoftwareCloudApi",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          }
        }
      },
      "id": "68c90b12-ae5c-470d-a41f-b9921abe264c",
      "name": "Download Log File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        86224,
        20416
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Combine log file content with ticket data\n// Get ticket data from Prepare Data for Analysis (before log file download)\nconst ticketData = $('Prepare Data for Analysis').item.json;\nconst logContent = $input.first().json;\n\n// Extract log content (limit to 30000 chars to avoid token limits)\nlet logFileContent = '';\nif (logContent && typeof logContent === 'string') {\n  logFileContent = logContent.substring(0, 30000);\n} else if (logContent && logContent.body) {\n  logFileContent = String(logContent.body).substring(0, 30000);\n} else if (logContent && typeof logContent === 'object') {\n  logFileContent = JSON.stringify(logContent).substring(0, 30000);\n}\n\n// Prepare log file info\nconst logFiles = ticketData.logFiles || [];\nlet logFileInfo = '';\nif (logFiles.length > 0) {\n  logFileInfo = logFiles.map((file, idx) => {\n    return `${idx + 1}. ${file.filename || 'unknown'} (${file.size || 0} bytes)`;\n  }).join('\\n');\n}\n\nreturn {\n  json: {\n    ...ticketData,\n    logFileContent: logFileContent,\n    logFileInfo: logFileInfo,\n    hasLogContent: logFileContent.length > 0,\n    logFileCount: logFiles.length\n  }\n};"
      },
      "id": "141ede4c-4623-41b5-bc44-f861ec6cc6cc",
      "name": "Prepare Log File Info",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        86384,
        20416
      ]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4-turbo",
          "mode": "list",
          "cachedResultName": "GPT-4-TURBO"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a bug triage assistant analyzing potential duplicate tickets. You MUST respond with ONLY valid JSON, no explanations.\n\n**CRITICAL: ONLY ANALYZE WHAT IS ACTUALLY PROVIDED**\n- DO NOT invent, hallucinate, or make up errors, issues, or problems that are not explicitly stated in the ticket\n- DO NOT analyze log files for errors that are not actually present in the log content provided\n- ONLY base your analysis on the actual ticket summary, description, and log file content (if provided)\n- If information is missing or unclear, state that in your reasoning - do not make assumptions about what the error might be\n\n**NEW TICKET:**\n- Key: {{ $json.newTicketKey || 'UNKNOWN' }}\n- Summary: {{ $json.newTicketSummary || 'No summary' }}\n- Description: {{ ($json.newTicketDescription || 'No description').substring(0, 500) }}\n- Components: {{ $json.newTicketComponents || 'None' }}\n- Labels: {{ $json.newTicketLabels || 'None' }}\n{{ $json.hasLogFiles ? '\\n- Log Files Attached (' + $json.logFileCount + '):\\n' + $json.logFileInfo : '' }}\n{{ $json.hasLogContent ? '\\n\\n**LOG FILE CONTENT (First 10000 chars):**\\n' + ($json.logFileContent || '').substring(0, 10000) : '' }}\n\n**EXISTING TICKETS (Last 90 days, {{ $json.existingTicketsCount || 0 }} total):**\n{{ ($json.existingTickets || []).slice(0, 15).map((ticket, i) => `${i + 1}. [${ticket.key}] ${ticket.summary}\\n   Status: ${ticket.status} | Components: ${ticket.components}\\n   Description: ${ticket.description}...\\n`).join('\\n') || 'No existing tickets found.' }}\n\n**TASK:**\nAnalyze if the new ticket is a potential duplicate based ONLY on what is actually provided in the ticket. If log files are attached and their content is provided above, use ONLY the actual log file content (error messages, stack traces, etc.) that is present - do not invent errors. If you cannot determine, set isDuplicate to false with low confidence.\n\n**YOU MUST RESPOND WITH ONLY THIS JSON FORMAT - NO OTHER TEXT:**\n{\"isDuplicate\": false, \"confidence\": \"low\", \"potentialDuplicates\": [], \"reasoning\": \"Brief explanation based ONLY on what is actually in the ticket\", \"similarityScore\": 0}"
            }
          ]
        },
        "options": {
          "temperature": 0.2
        }
      },
      "id": "146d7001-5a9a-4837-ba05-0431d8d64d73",
      "name": "Check for Duplicates",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        86544,
        20416
      ],
      "credentials": {
        "openAiApi": {
          "id": "LmN9WpOK1xEtISHT",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4-turbo-2024-04-09",
          "mode": "list",
          "cachedResultName": "GPT-4-TURBO-2024-04-09"
        },
        "messages": {
          "values": [
            {
              "content": "=You are an expert bug analyst. You MUST respond with ONLY valid JSON, no explanations or preamble.\n\n**CRITICAL: ONLY ANALYZE WHAT IS ACTUALLY PROVIDED**\n- DO NOT invent, hallucinate, or make up errors, issues, or problems that are not explicitly stated in the ticket\n- DO NOT analyze log files for errors that are not actually present in the log content provided\n- ONLY base your analysis on the actual ticket summary, description, and log file content (if provided)\n- If information is missing or unclear, state \"Unknown\" or \"Insufficient information\" - do not make up root causes\n- DO NOT invent error messages, stack traces, or technical issues that are not in the provided content\n\n**TICKET DETAILS:**\n- Key: {{ $('Prepare Log File Info').item.json.newTicketKey || $('Prepare Data for Analysis').item.json.newTicketKey || 'UNKNOWN' }}\n- Summary: {{ $('Prepare Log File Info').item.json.newTicketSummary || $('Prepare Data for Analysis').item.json.newTicketSummary || 'No summary provided' }}\n- Description: {{ ($('Prepare Log File Info').item.json.newTicketDescription || $('Prepare Data for Analysis').item.json.newTicketDescription || 'No description provided').substring(0, 2000) }}\n- Reporter: {{ $('Prepare Log File Info').item.json.newTicketReporter || $('Prepare Data for Analysis').item.json.newTicketReporter || 'Unknown' }}\n- Current Priority: {{ $('Prepare Log File Info').item.json.newTicketPriority || $('Prepare Data for Analysis').item.json.newTicketPriority || 'None' }}\n- Components: {{ $('Prepare Log File Info').item.json.newTicketComponents || $('Prepare Data for Analysis').item.json.newTicketComponents || 'None' }}\n- Labels: {{ $('Prepare Log File Info').item.json.newTicketLabels || $('Prepare Data for Analysis').item.json.newTicketLabels || 'None' }}\n{{ $('Prepare Log File Info').item.json.hasLogFiles ? '\\n\\n**ATTACHED LOG FILES:**\\n' + ($('Prepare Log File Info').item.json.logFileInfo || '') : '' }}\n{{ $('Prepare Log File Info').item.json.hasLogContent ? '\\n\\n**LOG FILE CONTENT (First 15000 chars):**\\n' + ($('Prepare Log File Info').item.json.logFileContent || '').substring(0, 15000) + '\\n\\nNote: The above log file content contains error messages, stack traces, or debugging information. Use ONLY the actual errors present in this content - do not invent errors.' : '' }}\n\nAnalyze this ticket and provide your assessment based ONLY on what is actually provided. Pay special attention to any log files attached - use ONLY the actual error messages, stack traces, or debugging information that is present in the log content. If information is limited, state that clearly - do not make up root causes or errors.\n\n**CRITICAL DOCUMENTATION RULES:**\n- DO NOT include any documentation in the relevantDocumentation field unless you have verified it actually exists on https://support.webai.com/hc/en-us\n- DO NOT create, invent, or hallucinate documentation URLs or article titles\n- DO NOT guess or assume documentation exists - if you are not certain, leave relevantDocumentation as an empty array []\n- Only include documentation you have personally verified exists by searching the actual site\n- If you cannot verify documentation exists, you MUST return relevantDocumentation: []\n- All URLs MUST be real, existing URLs from https://support.webai.com/hc/en-us/articles/...\n- Do not make up article titles, URLs, or content\n\n**YOU MUST RESPOND WITH ONLY THIS JSON FORMAT - NO OTHER TEXT:**\n{\"summary\": \"Brief summary of the bug based ONLY on what is provided\", \"rootCause\": {\"category\": \"Unknown\", \"hypothesis\": \"Best guess at root cause based ONLY on provided information\", \"confidence\": \"low\", \"technicalArea\": \"General\", \"reasoning\": \"Analysis reasoning based ONLY on actual ticket content\"}, \"priority\": {\"recommended\": \"Medium\", \"reasoning\": \"Priority reasoning\", \"factors\": [\"unknown impact\"], \"userImpact\": \"Unknown\", \"urgency\": \"Normal\"}, \"recommendedActions\": [\"Gather more information\", \"Investigate further\"], \"estimatedComplexity\": \"Unknown\", \"relevantDocumentation\": []}"
            }
          ]
        },
        "options": {
          "temperature": 0.3
        }
      },
      "id": "9d137fdb-1a56-4672-b93e-32e9706a478a",
      "name": "Analyze & Categorize Ticket",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        86800,
        20416
      ],
      "credentials": {
        "openAiApi": {
          "id": "LmN9WpOK1xEtISHT",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Helper function to extract JSON from text that might have extra content\nfunction extractJSON(text) {\n  if (typeof text !== 'string') return text;\n  \n  // Remove markdown code blocks\n  text = text.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  \n  // Try to find JSON object in the text\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    try {\n      return JSON.parse(jsonMatch[0]);\n    } catch (e) {\n      // If that fails, try the whole text\n    }\n  }\n  \n  return JSON.parse(text);\n}\n\n// Get the duplicate check result\nconst duplicateCheckItem = $('Check for Duplicates').item.json;\nlet duplicateCheck;\n\ntry {\n  const content = duplicateCheckItem.message?.content || duplicateCheckItem.text || duplicateCheckItem.content || JSON.stringify(duplicateCheckItem);\n  duplicateCheck = extractJSON(content);\n} catch (e) {\n  duplicateCheck = {\n    isDuplicate: false,\n    confidence: 'low',\n    potentialDuplicates: [],\n    reasoning: 'Could not parse duplicate check response',\n    similarityScore: 0\n  };\n}\n\n// Get the analysis result\nconst analysisItem = $('Analyze & Categorize Ticket').item.json;\nlet analysis;\n\ntry {\n  const content = analysisItem.message?.content || analysisItem.text || analysisItem.content || JSON.stringify(analysisItem);\n  analysis = extractJSON(content);\n} catch (e) {\n  analysis = {\n    summary: 'Could not parse analysis response',\n    rootCause: { category: 'Unknown', hypothesis: 'Unknown', confidence: 'low', technicalArea: 'Unknown', reasoning: 'Parse error' },\n    priority: { recommended: 'Medium', reasoning: 'Default', factors: ['unknown'], userImpact: 'Unknown', urgency: 'Normal' },\n    recommendedActions: ['Review ticket manually'],\n    estimatedComplexity: 'Unknown'\n  };\n}\n\n// Get the help docs search result\nconst helpDocsItem = $input.first().json;\nlet helpDocs;\n\ntry {\n  const content = helpDocsItem.message?.content || helpDocsItem.text || helpDocsItem.content || JSON.stringify(helpDocsItem);\n  helpDocs = extractJSON(content);\n} catch (e) {\n  helpDocs = {\n    foundHelpfulDocs: false,\n    isUserEducationIssue: false,\n    relevantArticles: [],\n    instructions: '',\n    summary: '',\n    recommendedPriority: null\n  };\n}\n\n// Get ticket data\nconst ticketData = $('Prepare Data for Analysis').item.json;\n\n// Determine final priority - if helpful docs found and it's a user education issue, set to Low\nlet finalPriority = analysis.priority?.recommended || 'Medium';\nlet priorityReasoning = analysis.priority?.reasoning || 'No reasoning';\n\nif (helpDocs.foundHelpfulDocs && helpDocs.isUserEducationIssue) {\n  finalPriority = 'Low';\n  priorityReasoning = 'Reduced to Low priority: This appears to be a user education issue. Relevant help documentation was found that addresses this topic.';\n}\n\n// Build help docs instructions for the ticket\nlet helpDocsInstructions = '';\nif (helpDocs.foundHelpfulDocs && helpDocs.instructions) {\n  helpDocsInstructions = '\\n\\nðŸ“š *HELP DOCUMENTATION FOUND*\\n\\n';\n  helpDocsInstructions += helpDocs.summary ? `*Summary:* ${helpDocs.summary}\\n\\n` : '';\n  helpDocsInstructions += `*Instructions:*\\n${helpDocs.instructions}\\n\\n`;\n  if (helpDocs.relevantArticles && helpDocs.relevantArticles.length > 0) {\n    helpDocsInstructions += '*Relevant Articles:*\\n';\n    helpDocs.relevantArticles.forEach((article, i) => {\n      helpDocsInstructions += `${i + 1}. [${article.title}](${article.url})\\n   ${article.relevance}\\n`;\n    });\n  }\n}\n\nreturn {\n  json: {\n    ticketKey: ticketData.newTicketKey,\n    ticketSummary: ticketData.newTicketSummary,\n    ticketDescription: ticketData.newTicketDescription,\n    ticketReporter: ticketData.newTicketReporter,\n    ticketPriority: ticketData.newTicketPriority,\n    ticketComponents: ticketData.newTicketComponents,\n    ticketLabels: ticketData.newTicketLabels,\n    \n    isDuplicate: duplicateCheck.isDuplicate || false,\n    duplicateConfidence: duplicateCheck.confidence || 'low',\n    potentialDuplicates: duplicateCheck.potentialDuplicates || [],\n    duplicateReasoning: duplicateCheck.reasoning || 'No reasoning provided',\n    similarityScore: duplicateCheck.similarityScore || 0,\n    \n    summary: analysis.summary || 'No summary',\n    rootCauseCategory: analysis.rootCause?.category || 'Unknown',\n    rootCauseHypothesis: analysis.rootCause?.hypothesis || 'Unknown',\n    rootCauseConfidence: analysis.rootCause?.confidence || 'low',\n    rootCauseTechnicalArea: analysis.rootCause?.technicalArea || 'Unknown',\n    rootCauseReasoning: analysis.rootCause?.reasoning || 'No reasoning',\n    \n    recommendedPriority: finalPriority,\n    priorityReasoning: priorityReasoning,\n    priorityFactors: analysis.priority?.factors || ['unknown'],\n    userImpact: analysis.priority?.userImpact || 'Unknown',\n    urgency: analysis.priority?.urgency || 'Normal',\n    \n    recommendedActions: analysis.recommendedActions || ['Review manually'],\n    estimatedComplexity: analysis.estimatedComplexity || 'Unknown',\n    \n    // Help docs data\n    foundHelpfulDocs: helpDocs.foundHelpfulDocs || false,\n    isUserEducationIssue: helpDocs.isUserEducationIssue || false,\n    helpDocsInstructions: helpDocsInstructions,\n    helpDocsSummary: helpDocs.summary || '',\n    helpDocsArticles: helpDocs.relevantArticles || [],\n    \n    // Relevant documentation from analysis\n    relevantDocumentation: analysis.relevantDocumentation || []\n  }\n};"
      },
      "id": "8e048072-eecd-422b-be2e-f14f4ade95e8",
      "name": "Merge Analysis Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        87408,
        20416
      ]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\n// Priority emoji mapping\nconst priorityEmoji = {\n  'Critical': 'ðŸ”´',\n  'High': 'ðŸŸ ',\n  'Medium': 'ðŸŸ¡',\n  'Low': 'ðŸŸ¢'\n};\n\nconst emoji = priorityEmoji[data.recommendedPriority] || 'âšª';\n\n// Helper to extract ticket key from potential duplicate (might be object or string)\nconst getDuplicateKey = (d) => typeof d === 'object' ? (d.key || JSON.stringify(d)) : d;\n\n// Truncate description for display (but show more)\nconst descriptionPreview = (data.ticketDescription || 'No description provided').substring(0, 500) + (data.ticketDescription && data.ticketDescription.length > 500 ? '...' : '');\n\n// Build Slack blocks\nconst blocks = [\n  {\n    type: 'header',\n    text: {\n      type: 'plain_text',\n      text: `${emoji} New Bug: ${data.ticketKey || 'Unknown'}`,\n      emoji: true\n    }\n  },\n  {\n    type: 'section',\n    text: {\n      type: 'mrkdwn',\n      text: `*${data.ticketSummary || 'No summary'}*`\n    },\n    accessory: {\n      type: 'button',\n      text: {\n        type: 'plain_text',\n        text: 'View in Jira',\n        emoji: true\n      },\n      url: `https://${data.jiraBaseUrl || 'webai-dev.atlassian.net'}/browse/${data.ticketKey || 'unknown'}`,\n      action_id: 'view_ticket'\n    }\n  },\n  { type: 'divider' },\n  {\n    type: 'section',\n    text: {\n      type: 'mrkdwn',\n      text: `*ðŸ“ Description:*\\n${descriptionPreview}`\n    }\n  },\n  { type: 'divider' },\n  {\n    type: 'section',\n    fields: [\n      {\n        type: 'mrkdwn',\n        text: `*ðŸ“Š Priority:*\\n${emoji} ${data.recommendedPriority || 'Medium'}\\n_(was: ${data.ticketPriority || 'None'})_`\n      },\n      {\n        type: 'mrkdwn',\n        text: `*ðŸ‘¤ Reporter:*\\n${data.ticketReporter || 'Unknown'}`\n      },\n      {\n        type: 'mrkdwn',\n        text: `*ðŸ·ï¸ Components:*\\n${data.ticketComponents || 'None'}`\n      },\n      {\n        type: 'mrkdwn',\n        text: `*âš™ï¸ Complexity:*\\n${data.estimatedComplexity || 'Unknown'}`\n      }\n    ]\n  },\n  { type: 'divider' },\n  {\n    type: 'section',\n    text: {\n      type: 'mrkdwn',\n      text: `*ðŸ” Root Cause Analysis:*\\n*Category:* ${data.rootCauseCategory || 'Unknown'} â†’ ${data.rootCauseTechnicalArea || 'General'}\\n*Hypothesis:* ${data.rootCauseHypothesis || 'Unknown'}\\n*Confidence:* ${(data.rootCauseConfidence || 'low').toUpperCase()}\\n\\n_${data.rootCauseReasoning || 'No detailed reasoning available'}_`\n    }\n  },\n  { type: 'divider' },\n  {\n    type: 'section',\n    text: {\n      type: 'mrkdwn',\n      text: `*ðŸ¤– AI Summary:*\\n${data.summary || 'No AI summary available'}`\n    }\n  },\n  {\n    type: 'section',\n    text: {\n      type: 'mrkdwn',\n      text: `*ðŸ’¡ Priority Reasoning:*\\n${data.priorityReasoning || 'No reasoning'}\\n*User Impact:* ${data.userImpact || 'Unknown'} | *Urgency:* ${data.urgency || 'Normal'}`\n    }\n  }\n];\n\n// Add help docs section if found\nif (data.foundHelpfulDocs) {\n  blocks.push(\n    { type: 'divider' },\n    {\n      type: 'section',\n      text: {\n        type: 'mrkdwn',\n        text: `*ðŸ“š HELP DOCUMENTATION FOUND${data.isUserEducationIssue ? ' - User Education Issue' : ''}*\\n\\n${data.helpDocsSummary || 'Documentation available for this issue.'}`\n      }\n    }\n  );\n  \n  // Add relevant articles\n  if (data.helpDocsArticles && data.helpDocsArticles.length > 0) {\n    const articlesText = data.helpDocsArticles.map((article, i) => \n      `${i + 1}. <${article.url}|${article.title}>\\n   _${article.relevance}_`\n    ).join('\\n');\n    \n    blocks.push({\n      type: 'section',\n      text: {\n        type: 'mrkdwn',\n        text: `*Relevant Articles:*\\n${articlesText}`\n      }\n    });\n  }\n}\n\n// Add duplicate warning if applicable\nif (data.isDuplicate && data.potentialDuplicates && data.potentialDuplicates.length > 0) {\n  const confidenceEmoji = { 'high': 'ðŸ”´', 'medium': 'ðŸŸ¡', 'low': 'ðŸŸ¢' }[data.duplicateConfidence] || 'âšª';\n  blocks.splice(2, 0, \n    { type: 'divider' },\n    {\n      type: 'section',\n      text: {\n        type: 'mrkdwn',\n        text: `${confidenceEmoji} *âš ï¸ POTENTIAL DUPLICATE DETECTED*\\n*Confidence:* ${(data.duplicateConfidence || 'unknown').toUpperCase()} (${data.similarityScore || 0}% similar)\\n*Similar to:* ${data.potentialDuplicates.map(d => { const k = getDuplicateKey(d); return `<https://${data.jiraBaseUrl || 'webai-dev.atlassian.net'}/browse/${k}|${k}>`; }).join(', ')}\\n_${data.duplicateReasoning || 'No reasoning'}_`\n      }\n    }\n  );\n}\n\n// Add recommended actions\nconst actions = data.recommendedActions || ['Review manually'];\nblocks.push(\n  { type: 'divider' },\n  {\n    type: 'section',\n    text: {\n      type: 'mrkdwn',\n      text: `*âœ… Recommended Actions:*\\n${actions.map((a, i) => `${i + 1}. ${a}`).join('\\n')}`\n    }\n  }\n);\n\nreturn {\n  json: {\n    blocks: blocks,\n    text: `New Bug: ${data.ticketKey || 'Unknown'} - ${data.ticketSummary || 'No summary'}`,\n    ...data\n  }\n};"
      },
      "id": "4856be58-c906-4fba-8fdc-288353a6a270",
      "name": "Format Slack Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        87680,
        20272
      ]
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "#andrew-n8n-test",
          "mode": "name"
        },
        "messageType": "block",
        "blocksUi": "={{ JSON.stringify({ blocks: $json.blocks }) }}",
        "text": "={{ $json.text }}",
        "otherOptions": {
          "unfurl_links": false,
          "unfurl_media": false
        }
      },
      "id": "5c4f7ebd-2e04-4a9d-b618-97eeaf02dcfb",
      "name": "Send to Slack",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.2,
      "position": [
        87904,
        20272
      ],
      "webhookId": "6966e48e-afe3-4d14-9711-464ab40d744a",
      "credentials": {
        "slackApi": {
          "id": "96bElXC23j1WCbNw",
          "name": "Slack account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "combineOperation": "all"
          },
          "conditions": [
            {
              "id": "is_duplicate",
              "leftValue": "={{ $json.isDuplicate || $('Merge Analysis Results').item.json.isDuplicate || false }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "e6961e17-c06b-492b-a414-5f575fac98e9",
      "name": "Is High-Confidence Duplicate?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        87776,
        20816
      ]
    },
    {
      "parameters": {
        "operation": "update",
        "issueKey": "={{ $json.ticketKey || $('Merge Analysis Results').item.json.ticketKey || $('Jira Trigger - New Bug Created').item.json.issue?.key || $('Jira Trigger - New Bug Created').item.json.key }}",
        "updateFields": {
          "labels": "={{ (() => { const data = $json; const labels = data.ticketLabels || []; const labelArray = Array.isArray(labels) ? labels : (typeof labels === 'string' ? labels.split(', ').filter(l => l.trim()) : []); const filtered = labelArray.filter(l => l && l.trim() !== 'Duplicate' && l.trim() !== 'potential-duplicate'); return [...filtered, 'Duplicate']; })() }}"
        }
      },
      "id": "62131be1-3fc7-4e92-a29d-0d226049a952",
      "name": "Add Duplicate Label",
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        88160,
        20864
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "resource": "issueComment",
        "issueKey": "={{ $('Merge Analysis Results').item.json.ticketKey || $json.ticketKey || $('Jira Trigger - New Bug Created').item.json.issue?.key || $('Jira Trigger - New Bug Created').item.json.key }}",
        "comment": "=ðŸ¤– *Automated Triage Analysis*\n\n---\n\n{{ $json.isDuplicate ? '*âš ï¸ POTENTIAL DUPLICATE DETECTED*\\n*Confidence:* ' + ($json.duplicateConfidence || 'unknown').toUpperCase() + ' (' + ($json.similarityScore || 0) + '% similar)\\n*Similar Tickets:* ' + ($json.potentialDuplicates || []).map(d => typeof d === 'object' ? d.key || JSON.stringify(d) : d).join(', ') + '\\n*Reasoning:* ' + ($json.duplicateReasoning || 'N/A') + '\\n\\n---\\n\\n' : '' }}{{ $json.foundHelpfulDocs ? '*ðŸ“š HELP DOCUMENTATION FOUND' + ($json.isUserEducationIssue ? ' - USER EDUCATION ISSUE' : '') + '*\\n\\n' + ($json.helpDocsSummary || '') + '\\n\\n' + ($json.helpDocsArticles || []).map((a, i) => (i + 1) + '. [' + (a.title || 'Link').replace(/\\|/g, '') + '|' + a.url + ']\\n   ' + (a.relevance || 'Relevant documentation')).join('\\n') + '\\n\\n---\\n\\n' : '' }}{{ $json.relevantDocumentation && $json.relevantDocumentation.length > 0 ? '*ðŸ“– RELEVANT DOCUMENTATION*\\n\\n' + ($json.relevantDocumentation || []).map((a, i) => (i + 1) + '. [' + (a.title || 'Link').replace(/\\|/g, '') + '|' + a.url + ']\\n   ' + (a.relevance || 'Relevant documentation')).join('\\n') + '\\n\\n---\\n\\n' : '' }}*ðŸ” ROOT CAUSE ANALYSIS*\n*Category:* {{ $json.rootCauseCategory || 'Unknown' }} - {{ $json.rootCauseTechnicalArea || 'General' }}\n*Hypothesis:* {{ $json.rootCauseHypothesis || 'Unknown' }}\n*Confidence:* {{ ($json.rootCauseConfidence || 'low').toUpperCase() }}\n*Analysis:* {{ $json.rootCauseReasoning || 'No analysis available' }}\n\n---\n\n*ðŸ“Š PRIORITY RECOMMENDATION*\n*Recommended:* {{ $json.recommendedPriority || 'Medium' }} (Current: {{ $json.ticketPriority || 'None' }})\n*Reasoning:* {{ $json.priorityReasoning || 'N/A' }}\n*User Impact:* {{ $json.userImpact || 'Unknown' }}\n*Urgency:* {{ $json.urgency || 'Normal' }}\n*Key Factors:* {{ ($json.priorityFactors || ['unknown']).join(', ') }}\n\n---\n\n*âœ… RECOMMENDED ACTIONS*\n{{ ($json.recommendedActions || ['Review manually']).map((action, i) => (i + 1) + '. ' + action).join('\\n') }}\n\n---\n\n*Estimated Complexity:* {{ $json.estimatedComplexity || 'Unknown' }}\n\n_Analysis generated on {{ $now.toISO() }}_",
        "options": {}
      },
      "id": "053fdf11-919a-44b3-a49e-db78b2e3327b",
      "name": "Add Jira Comment",
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        87936,
        20480
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "update",
        "issueKey": "={{ $json.ticketKey || $('Merge Analysis Results').item.json.ticketKey || $('Jira Trigger - New Bug Created').item.json.key || $input.first().json.key }}",
        "updateFields": {
          "labels": "={{ Array.isArray($json.ticketLabels) ? [...$json.ticketLabels.filter(l => l !== 'auto-triaged'), 'auto-triaged'] : ($json.ticketLabels ? $json.ticketLabels.split(', ').filter(l => l && l !== 'auto-triaged').concat(['auto-triaged']) : ['auto-triaged']) }}"
        }
      },
      "id": "713137c3-1490-479d-9f7a-48ecad3450be",
      "name": "Mark as Triaged",
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        88144,
        20480
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Map LLM priority values to Jira priority IDs\n// Jira priority mapping: 1 = Lowest, 2 = Low, 3 = Medium, 4 = High, 5 = Urgent\nconst data = $input.first().json;\nconst llmPriority = (data.recommendedPriority || 'Medium').trim();\n\n// Map LLM priorities to Jira priority IDs (1-5)\nconst priorityMap = {\n  'Critical': '5',\n  'Highest': '5',\n  'Urgent': '5',\n  'urgent': '5',\n  'High': '4',\n  'high': '4',\n  'Medium': '3',\n  'medium': '3',\n  'Normal': '3',\n  'Low': '2',\n  'low': '2',\n  'Lowest': '1',\n  'lowest': '1'\n};\n\n// Try to map, fallback to Medium (3) if not found\nlet jiraPriorityId = priorityMap[llmPriority] || '3';\n\n// If still not mapped, try common alternatives based on keywords\nif (!['1', '2', '3', '4', '5'].includes(jiraPriorityId)) {\n  const lowerPriority = llmPriority.toLowerCase();\n  // Map to closest match based on priority levels\n  if (lowerPriority.includes('critical') || lowerPriority.includes('highest') || lowerPriority.includes('urgent') || lowerPriority.includes('blocker')) {\n    jiraPriorityId = '5'; // Urgent\n  } else if (lowerPriority.includes('high') || lowerPriority.includes('major')) {\n    jiraPriorityId = '4'; // High\n  } else if (lowerPriority.includes('medium') || lowerPriority.includes('normal')) {\n    jiraPriorityId = '3'; // Medium\n  } else if (lowerPriority.includes('low')) {\n    // Distinguish between Low and Lowest\n    if (lowerPriority.includes('lowest') || lowerPriority.includes('trivial')) {\n      jiraPriorityId = '1'; // Lowest\n    } else {\n      jiraPriorityId = '2'; // Low\n    }\n  } else {\n    jiraPriorityId = '3'; // Default fallback to Medium\n  }\n}\n\nreturn {\n  json: {\n    ...data,\n    jiraPriority: jiraPriorityId,\n    originalPriority: llmPriority\n  }\n};"
      },
      "id": "87bd5731-af39-4eb3-98a0-72e6c4eeeec1",
      "name": "Map Priority to Jira Format",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        88144,
        20688
      ]
    },
    {
      "parameters": {
        "operation": "get",
        "issueKey": "={{ $json.ticketKey || $('Map Priority to Jira Format').item.json.ticketKey || $('Merge Analysis Results').item.json.ticketKey || $('Jira Trigger - New Bug Created').item.json.issue?.key || $('Jira Trigger - New Bug Created').item.json.key }}",
        "additionalFields": {}
      },
      "id": "c254ddc2-3f6c-4189-8b71-56bde08efcb1",
      "name": "Get Issue for Priority",
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        88288,
        20688
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Prepare priority updateFields object for Jira API\n// Get data from Map Priority to Jira Format node\nconst mappedData = $('Map Priority to Jira Format').item.json;\nconst priorityId = String(mappedData.jiraPriority || '3');\nconst ticketKey = mappedData.ticketKey || $('Merge Analysis Results').item.json.ticketKey || $('Jira Trigger - New Bug Created').item.json.issue?.key || $('Jira Trigger - New Bug Created').item.json.key;\n\n// Create the updateFields object in the format Jira expects\nreturn {\n  json: {\n    ticketKey: ticketKey,\n    priorityUpdateFields: {\n      priority: {\n        id: priorityId\n      }\n    }\n  }\n};"
      },
      "id": "53239d5b-f073-4ed9-8e2f-c516118bf04f",
      "name": "Prepare Priority Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        88432,
        20688
      ]
    },
    {
      "parameters": {
        "operation": "update",
        "issueKey": "={{ $('Prepare Priority Update').item.json.ticketKey }}",
        "updateFields": {}
      },
      "id": "53eb0784-7923-43bf-ab3d-c1e46e438631",
      "name": "Update Priority",
      "type": "n8n-nodes-base.jira",
      "typeVersion": 1,
      "position": [
        88608,
        20688
      ],
      "credentials": {
        "jiraSoftwareCloudApi": {
          "id": "v9NVSPaZW8j1aT2F",
          "name": "Jira SW Cloud account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4-turbo",
          "mode": "list",
          "cachedResultName": "GPT-4-TURBO"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a support documentation specialist. You MUST verify documentation actually exists before including it.\n\n**ABSOLUTE CRITICAL RULES - NO EXCEPTIONS:**\n- DO NOT create, invent, hallucinate, or guess documentation URLs or articles\n- DO NOT return foundHelpfulDocs: true unless you have PERSONALLY VERIFIED the documentation exists on https://support.webai.com/hc/en-us\n- DO NOT assume documentation exists - if you are uncertain, return foundHelpfulDocs: false\n- DO NOT make up article titles, URLs, or content - this is strictly forbidden\n- If you cannot verify documentation exists by actually searching the site, you MUST return foundHelpfulDocs: false\n- All URLs MUST be real, existing URLs from https://support.webai.com/hc/en-us/articles/... that you have verified\n- When in doubt, return foundHelpfulDocs: false - it is better to return no docs than fake docs\n- Only return articles you have personally verified exist by searching the actual documentation site\n\n**BUG DETAILS:**\n- Summary: {{ $('Prepare Data for Analysis').item.json.newTicketSummary || 'No summary' }}\n- Description: {{ $('Prepare Data for Analysis').item.json.newTicketDescription || 'No description' }}\n- Components: {{ $('Prepare Data for Analysis').item.json.newTicketComponents || 'None' }}\n\n**DOCUMENTATION SITE:** https://support.webai.com/hc/en-us\n\n**VERIFICATION REQUIREMENTS:**\n1. You MUST actually search https://support.webai.com/hc/en-us to verify documentation exists\n2. You MUST verify each article URL actually exists before including it\n3. If you cannot verify documentation exists, you MUST return foundHelpfulDocs: false\n4. DO NOT guess or assume - only include what you can verify\n\n**TASK:**\n1. Based on the bug summary and description, identify key topics/features/errors mentioned\n2. ONLY if you can VERIFY real documentation exists on https://support.webai.com/hc/en-us, return it\n3. If you cannot verify documentation exists, return foundHelpfulDocs: false\n4. If you find verified helpful documentation, provide step-by-step instructions from those ACTUAL docs\n5. Determine if this is a user education issue (can be resolved with docs) vs a real bug\n\n**YOU MUST RESPOND WITH ONLY THIS JSON FORMAT - NO OTHER TEXT:**\nIf you can VERIFY documentation exists: {\"foundHelpfulDocs\": true, \"isUserEducationIssue\": true, \"relevantArticles\": [{\"title\": \"Actual Verified Article Title\", \"url\": \"https://support.webai.com/hc/en-us/articles/VERIFIED-ARTICLE-ID\", \"relevance\": \"Why this helps\"}], \"instructions\": \"Step-by-step instructions from verified docs\", \"summary\": \"Brief summary\", \"recommendedPriority\": \"Low\"}\nIf you CANNOT verify documentation exists: {\"foundHelpfulDocs\": false, \"isUserEducationIssue\": false, \"relevantArticles\": [], \"instructions\": \"\", \"summary\": \"\", \"recommendedPriority\": null}"
            }
          ]
        },
        "options": {
          "temperature": 0.2
        }
      },
      "id": "4e5d9d65-79d7-4dd9-8f65-3bbb25f3a2d3",
      "name": "Search Help Docs",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        87104,
        20416
      ],
      "credentials": {
        "openAiApi": {
          "id": "LmN9WpOK1xEtISHT",
          "name": "OpenAi account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Jira Trigger - New Bug Created": {
      "main": [
        [
          {
            "node": "Check if Bug Ticket",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Bug Ticket": {
      "main": [
        [
          {
            "node": "Check if Already Triaged",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Already Triaged": {
      "main": [
        [
          {
            "node": "Mark as Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark as Processing": {
      "main": [
        [
          {
            "node": "Extract New Ticket Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract New Ticket Data": {
      "main": [
        [
          {
            "node": "Get Recent Bug Tickets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Recent Bug Tickets": {
      "main": [
        [
          {
            "node": "Prepare Data for Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Data for Analysis": {
      "main": [
        [
          {
            "node": "Fetch Log File Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Log File Content": {
      "main": [
        [
          {
            "node": "Download Log File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Log File": {
      "main": [
        [
          {
            "node": "Prepare Log File Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Log File Info": {
      "main": [
        [
          {
            "node": "Check for Duplicates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Duplicates": {
      "main": [
        [
          {
            "node": "Analyze & Categorize Ticket",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze & Categorize Ticket": {
      "main": [
        [
          {
            "node": "Search Help Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Help Docs": {
      "main": [
        [
          {
            "node": "Merge Analysis Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Analysis Results": {
      "main": [
        [
          {
            "node": "Map Priority to Jira Format",
            "type": "main",
            "index": 0
          },
          {
            "node": "Format Slack Message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Add Jira Comment",
            "type": "main",
            "index": 0
          },
          {
            "node": "Is High-Confidence Duplicate?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Jira Comment": {
      "main": [
        [
          {
            "node": "Mark as Triaged",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Priority to Jira Format": {
      "main": [
        [
          {
            "node": "Get Issue for Priority",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Issue for Priority": {
      "main": [
        [
          {
            "node": "Prepare Priority Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Priority Update": {
      "main": [
        [
          {
            "node": "Update Priority",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Slack Message": {
      "main": [
        [
          {
            "node": "Send to Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is High-Confidence Duplicate?": {
      "main": [
        [
          {
            "node": "Add Duplicate Label",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "665afa92-9a43-41ec-8aaf-bd7bbde697e2",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "f77e25729e52ebbbe315e49d8be45ec253824ba87b956c4a449129aca2bf1fb9"
  },
  "id": "o5w3kNVCugpT4lPY",
  "tags": []
}